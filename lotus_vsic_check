#!/usr/bin/perl
# TRCM
use strict;
use warnings;
use POSIX qw(strftime);
use Time::HiRes qw(sleep); # For floaty seconds
use LWP::UserAgent;

my $vsic_base = 'http://vsic.lotuscars.com/downloads/software';
# http://en.wikipedia.org/wiki/ISO_8601 ftw.
# Allows us to compare dates lexicographically (ie, using cmp, lt, gt).
my $today     = strftime "%Y-%m-%d", localtime;
my $sleep     = 0.3;
my $debug     = 0;
my %c = (
    green => '32',
    yellow => '33',
    red => '31',
);
my $new_flag  = 0;
local $|      = 1; # Flush to STDOUT as it happens, don't buffer

# See bottom of script for field definitions
my %models = (
    "EVORA S (ROW) '12-'15" => {
        'URL' => '?field_models_tr_tid=74'.        # Evora
                 '&field_model_years_tr_tid=99'.   # 2015
                 '&field_gearbox_tr_tid=100'.      # Manual
                 '&field_engine_type_tr_tid=7'.    # 2GR-FE sc (257.5kW)
                 '&field_chassis_spec_tr_tid=65',  # RHD Other
        'DESC' => undef,
        'DATECRP' => undef,
    },
    "EVORA NA (ROW) '12-'15" => {
        'URL' => '?field_models_tr_tid=74'.        # Evora
                 '&field_model_years_tr_tid=96'.   # 2012
                 '&field_gearbox_tr_tid=100'.      # Manual
                 '&field_engine_type_tr_tid=6'.    # 2GR-FE
                 '&field_chassis_spec_tr_tid=65',  # RHD Other
        'DESC' => undef,
        'DATECRP' => undef,
    },
    "EXIGE S (ROW) '12-'16" => {
        'URL' => '?field_models_tr_tid=75'.        # Exige
                 '&field_model_years_tr_tid=96'.   # 2012
                 '&field_gearbox_tr_tid=100'.      # Manual
                 '&field_engine_type_tr_tid=7'.    # 2GR-FE sc (257.5kW)
                 '&field_chassis_spec_tr_tid=65',  # RHD Other
        'DESC' => undef,
        'DATECRP' => undef,
    }
);

# Subroutine for scraping the Lotus VSIC pages
sub vsic_check {
    my %hash = %{$_[0]};
    my $model = $_[1];
    my $lwp = LWP::UserAgent->new;
    my $response = $lwp->get($vsic_base.$hash{$model}{'URL'});
    if ($response->is_success) {
        my $response_body = $response->decoded_content;
        # "&#039;12-&#039;15 Evora S & S-IPS Supercharged hash Engine Management Program .CRP File R132E0096"
        $response_body =~ m/(\&#039;.*([[:upper:]][[:digit:]]{3}[[:upper:]][[:digit:]]{4}))/;
        $hash{$model}{'DESC'} = $1;
        $hash{$model}{'CRP'} = $2;
        print "DEBUG: $hash{$model}{'DESC'}\n" if ($debug);
    } else {
        die "Error getting the VSIC page : $vsic_base.$hash{$model}{'URL'}\n";
    }
    die "Couldn't find the CRP field : $vsic_base.$hash{$model}{'URL'}\n" unless defined($hash{$model}{'CRP'});
    # Tidy up the HTML quoted characters, though do we even care about the description?
    $hash{$model}{'DESC'} =~ s/\&amp;/&/g;
    $hash{$model}{'DESC'} =~ s/\&#039;/\'/g;
    $hash{$model}{'DESC'} =~ s/\ +Engine.*$//g;
    $hash{$model}{'DESC'} =~ s/^/"/g;
    $hash{$model}{'DESC'} =~ s/$/"/g;
    return $hash{$model}{'CRP'};
}

# TODO
# Possibly (with a -w argument)? append new VSIC values to the DATA segment
sub append_new_values {
    seek DATA, 0, 2; # go to the end of the source file
    my $offset = tell(DATA); # remember where that is
    open my $self, '>>', $0 or die $!; # of course, you could use DATA instead of $self here
    seek $self, $offset, 0; # go to the previously recorded position
    foreach my $model (sort keys %models) {
        print {$self} "$today,$model,$models{$model}{'CRP'},newdata!!\n";
    }
}

# Read the CRP versions we've saved in the __DATA__ segment into %models
print "\e[$c{red}m [+] Loading CRP version data...\e[m\n"; sleep($sleep);
my $offset = tell DATA; # save the position
seek DATA, $offset, 0;  # position filehandle just past __DATA__
while (my $line = <DATA>) {
    chomp $line;
    my ($date,$model,$crp) = split(/,/,$line);
    # Build an array of CRP {date,version} tuples
    push @{$models{$model}{'DATECRP'}}, [$date,$crp];
}
# Sort DATECRP array. Using arrow notation for first element of array reference.
print "\e[$c{red}m [+] Sorting...\e[m\n"; sleep($sleep);
foreach my $model (sort keys %models) {
    @{$models{$model}{'DATECRP'}} = sort { $a->[0] cmp $b->[0] } @{$models{$model}{'DATECRP'}};
}

print "\e[$c{red}m [+] Checking Lotus VSIC for updates...\e[m\n"; sleep($sleep);
foreach my $model (sort keys %models) {
    print "\e[$c{green}m$model :\e[m\n";
    my $array_pos=0;
    foreach my $datecrp (@{$models{$model}{'DATECRP'}}) {
        my $date = @$datecrp[0];
        my $crp  = @$datecrp[1];
        if ($array_pos == $#{$models{$model}{'DATECRP'}}) {
            # We're the last {date,crp} to print, check VSIC if we're up to date
            # unless $date is today, then dont bother VSIC, print what we have
            if ($today gt $date) {
                sleep($sleep);
                my $crp_new = vsic_check(\%models,$model);
                if ($crp eq $crp_new) {
                    printf("\t%-10s, %-20s <--( Unchanged )\n",$date,$crp);
                } else {
                    printf("\t%-10s, %-20s\n",$date,$crp);
                    printf("\t%-10s, %-20s <--( \e[%dmNew CRP version!\e[m )\n",$today,$crp_new,$c{yellow});
                    $new_flag=1;
                }
            } else {
                printf("\t%-10s, %-20s <--( Current )\n",$date,$crp);
            }
        } else {
            printf("\t%-10s, %-20s\n",$date,$crp);
        }
        $array_pos++;
    }
}
print "\e[$c{red}m [!] New CRP versions found, consider updating with '$0 --update'\e[m\n" if ($new_flag);

# field_models_tr_tid :
#    "70" 2-Eleven
#    "71" Elise
#    "72" Elise EU
#    "73" Elise RoW
#    "74" Evora
#    "75" Exige
#    "76" Exige EU
#    "77" Exige RoW
#    "104" Exige Coupe EU
#    "105" Exige Coupe RoW
#    "106" Exige Roadster EU
#    "107" Exige Roadster RoW
# field_model_years_tr_tid :
#    "88" 2004
#    "89" 2005
#    "90" 2006
#    "91" 2007
#    "92" 2008
#    "93" 2009
#    "94" 2010
#    "95" 2011
#    "96" 2012
#    "97" 2013
#    "98" 2014
#    "99" 2015
#    "108" 2016
# field_gearbox_tr_tid :
#    "100" Manual
#    "101" Automatic (IPS)
# field_engine_type_tr_tid :
#    "3" 1ZR 136
#    "4" 1ZZ
#    "5" 1ZZ 140
#    "6" 2GR-FE
#    "7" 2GR-FE sc (257.5kW)
#    "8" 2ZR sc 220 c/c
#    "9" 2ZZ 190 evap
#    "10" 2ZZ
#    "11" 2ZZ no evap
#    "12" 2ZZ sc 190 no evap
#    "13" 2ZZ sc 220
#    "14" 2ZZ sc 220 c/c
#    "15" 2ZZ sc 220 non c/c
#    "16" 2ZZ sc 240
#    "17" 2ZZ sc 240 c/c
#    "18" 2ZZ sc 255
#    "19" 2ZZ sc 255 no evap
#    "20" 2ZZ sc 260
#    "21" 2ZZ sc 260 c/c
#    "22" 2ZZ sc 260 c/c no evap
#    "23" 2ZZ sc 260 no evap
#    "24" 2ZZ sc 270
#    "25" Electric
#    "26" Motorsport
#    "113" 1ZR-FAE
#    "114" 2ZR-FE sc ic
#    "120" 2GR-FE sc (298kW)
# field_chassis_spec_tr_tid :
#    "50" Centre Drive Track
#    "51" China
#    "52" Gulf States
#    "53" LDD AC
#    "54" LHD Canada
#    "55" LHD Canada AC
#    "56" LHD Fed. AC
#    "57" LHD Other
#    "58" LHD SVA
#    "59" LHD SVA AC
#    "60" LHD Track
#    "61" LHD USA
#    "62" MSport LHD
#    "63" MSport RHD
#    "64" RHD AC
#    "65" RHD Other
#    "66" RHD SVA
#    "67" RHD Track
#    "68" RHD U.K. SVA
#    "69" RHD U.K. SVA AC
#    "115" Prototype
#    "116" LHD Federal
#    "117" GCC
#    "118" RHD SVA AC

__DATA__
2017-03-01,EVORA S (ROW) '12-'15,TESTTESTTEST
2017-04-18,EXIGE S (ROW) '12-'16,TESTTESTTEST
2017-04-18,EVORA NA (ROW) '12-'15,TESTTESTTEST
2017-03-01,EVORA NA (ROW) '12-'15,TESTTESTTEST
2017-04-18,EVORA S (ROW) '12-'15,R132E0096
2017-03-01,EXIGE S (ROW) '12-'16,TESTTESTTEST
2017-04-19,EVORA NA (ROW) '12-'15,P132E0092
